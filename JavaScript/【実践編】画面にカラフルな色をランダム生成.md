*目次*
* [概要](#概要)
* [RGBを使用してランダム生成](#RGBを使用してランダム生成)
* [相対値構文など](#相対値構文など)
* [使い方](#使い方)

## 概要

[基礎知識編](https://github.com/ren-github-account/Today-I-Learned/blob/main/JavaScript/%E3%80%90%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E7%B7%A8%E3%80%91%E7%94%BB%E9%9D%A2%E3%81%AB%E3%82%AB%E3%83%A9%E3%83%95%E3%83%AB%E3%81%AA%E8%89%B2%E3%82%92%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E7%94%9F%E6%88%90.md)で必要な知識はまとめたので、あとは以下のページを参考にコードを実行してみた結果をまとめていく。

https://sbfl.net/blog/2018/05/21/javascript-generate-better-color/

### RGBを使用してランダム生成



```
<body>

<script>

// 四角形を入れるコンテナ。
// flexboxで横並びにして、横方向にはみ出したら折り返すようにする。
const colorBoxContainer = document.createElement('div');
colorBoxContainer.style.display = 'flex';
colorBoxContainer.style.flexWrap = 'wrap';

// 色のついた四角形を100個作って先ほどのコンテナの中に入れる。
for(let i=0; i<100; i++) {
  // サイズは100px x 100px。
  const colorBox = document.createElement('div');
  colorBox.style.width = '100px';
  colorBox.style.height = '100px';

  // 色は完全にランダム。
  const r = Math.round(Math.random() * 255);
  const g = Math.round(Math.random() * 255);
  const b = Math.round(Math.random() * 255);
  colorBox.style.backgroundColor = `rgb(${r},${g},${b})`;

  colorBoxContainer.appendChild(colorBox);
}

// コンテナをbodyに追加する。
document.body.appendChild(colorBoxContainer);

</script>

</body>
```

**解説**

上記のコードを実行すると、**画面の右側に謎のスペースが空いてしまう。** これはなぜそうなるかというと、これは`flex-wrap: wrap`を設定しているために起こる。

`flex-wrap: wrap`に設定すると、コンテナ(上記のコードでは`div要素`)の領域内に収まりきらくなると次の行に折り返して表示されるようになる。つまり、上記のコードでは生成される色の付いたブロックの大きさを`100x100`にしているため、幅の`100px`が画面の幅に入りきらずに次の行に折り返されるという動作し、このことによって**画面の右側に余分な空白が空いてしまうということになる。**

なので`width`と`height`をそれぞれ`50px`に変更すると、**画面右側の空白は少なくなる。**

あと最後の行の`document.body.appendChild(colorBoxContainer);`を書かないとどうなるかというと、実行しても真っ白な画面が表示される。

これは **`document.createElement`で要素を作成しただけではダメ**で、`appendChild`で要素を表すノード内に追加する必要があるから。

**注意点**

`styleオブジェクト`を使って`color`などを指定する時は**シングルクォーテーションもしくはダブルクォーテーションで囲むか、テンプレートリテラルを使用する時のバッククォーテーション「\`」で囲むのを忘れずに。** そうしないとエラーになる。

### 相対値構文など

`rgb()関数`を使って色を指定する方法には**絶対値構文**と**相対値構文**の2種類が存在する。

絶対値構文については上記のコードでも使用したように、値が一つに定まる通常の指定方法なので問題ないと思う。

一方で**相対値構文**を使用すると、起点となる色をもとにして透明度だけ変更したり、起点色の`rgb値`のうち`r`の値だけ使用して色を設定したりといったように、**起点色という一つの色をもとに柔軟な色設定が可能となる。**

### 使い方

相対値構文は以下のように書く。

```
rgb(from <color> R G B[ / A])
```

`<color>`の部分には`hsl(0 100% 50%)`などを記述する。

具体的には以下のように書く。

```
rgb(from hsl(0 100% 50%) r g b)
```

上記のコードは`from`で指定した色(`hsl(0 100% 50%)`は**赤**を表す)をそのまま出力する。

上記のコードでは起点色をそのまま出力するだけだったが、今度は起点色をもとにして実際に変更を加えてる。

以下のように書く。

```
rgb(from hsl(0 100% 50%) r 80 80)
```

上記のコードを実行すると以下の動作が行われる。( 参照:[MDN](https://developer.mozilla.org/ja/docs/Web/CSS/color_value/rgb) )

||動作|
|-|-|
|①|起点色（`hsl(0 100% 50%)`）を同等の `rgb()` に変換します（`rgb(255 0 0)`)。|
|②|出力色のRチャネル値を起点色の`rgb()`相当のRチャネル値（`255`）に設定します。|
|③|出力色の G および B チャネル値を、起点色に基づかない新しい値に設定します：それぞれ `80` および `80`。|

以上の動作が行われ、この場合の最終的な出力色は`rgb(255 80 80)`となる。

**便利ツール**

