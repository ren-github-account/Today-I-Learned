*目次*
* [前提](#前提)
* [オブジェクト内の関数の省略記法](#オブジェクト内の関数の省略記法)
* [オブジェクトリテラル](#オブジェクトリテラル)
* [オブジェクトリテラルの使用場面](#オブジェクトリテラルの使用場面)
* [ブラケット記法で引数を使って値を取得](#ブラケット記法で引数を使って値を取得)
* [ブラケット記法の使用場面](#ブラケット記法の使用場面)
* [オブジェクトの値を更新する](#オブジェクトの値を更新する)
* [オブジェクトに新しいプロパティを追加](#オブジェクトに新しいプロパティを追加)
* [中括弧とは](#中括弧とは)
* [ブラケット記法を使ってプロパティ名やその値を変数で管理する](#ブラケット記法を使ってプロパティ名やその値を変数で管理する)
* [thisとは何か](#thisとは何か)
* [コンストラクターの導入](#コンストラクターの導入)
* [まとめ](#まとめ)

## 概要
本ページの内容はMDNのJavaScript入門にある「JavaScript オブジェクトの基本」というタイトルのページの内容を自分なりにまとめたものになる。

【リンク】

https://developer.mozilla.org/ja/docs/Learn/JavaScript/Objects/Basics

## 前提
オブジェクト指向プログラミングのことを略称で「`OOP`」と呼ぶ。

「`OOP`」は「Object-oriented programming」の略。`oriented`は「方向づけられた, ～指向の」などの意味がある。

OOPとは、「**システムをオブジェクトの集合としてモデル化すること**」を指す。

## 本編
### オブジェクト内の関数の省略記法

オブジェクト内の関数は基本は以下のように書く。

```
プロパティ名: function() {}, …(以下略)
```

だけど、上記の`:`(コロン)と`function`を省略して以下のようにも書ける。

```
プロパティ名() {}, …(以下略)
```

### オブジェクトリテラル

以下のコードのように「**作成することになったオブジェクトのコンテンツを文字通り書き出したもの**」のことを**オブジェクトリテラル**と呼ぶ。

これは**クラスからインスタンス化されたオブジェクトとは区別**される。
```
const person = {
  name:["Bob", "Smith"],
  age:32,
 };
```
オブジェクトの中身を取り出したい場合はコンソール画面に以下のように入力する。

```
person.name; /*  ['Bob', 'Smith']と出力される。
person.age;　/* 32と出力される。
```

### オブジェクトリテラルの利用場面
オブジェクトリテラルを使用してオブジェクトを作成するのは、以下のように場面で使う。

```
例えば、データベースに入れるリクエストをサーバーに送信するような場合にとても一般的です。
単一のオブジェクトを送信することは、複数のアイテムを個別に送信するよりもはるかに効率的であり、
個々のアイテムを名前で識別したい場合には、配列よりも扱いやすいときがあります。
```
引用:https://developer.mozilla.org/ja/docs/Learn/JavaScript/Objects/Basics

### ブラケット記法で引数を使って値を取得
以下のコードでは、`logProperty`関数を定義して、その引数を`propertyName`とすることで、`関数名("プロパティ名")`とコンソールに入力するとプロパティの値を取り出せるようにしている。

```
const person = {
  name:["Bob","Smith"],
  age:32
     };

function logProperty(propertyName) {  /* logProperty関数を定義 引数をpropertyNameに設定
  console.log(person[propertyName]);　/* ここでオブジェクト名[引数]とすることで、
　　　　　　　　　　　　　　　　　　　　　　引数に入力した時にブラケット記法で認識されるようにしている
 }
```

値を取り出すにはコンソール画面に以下のように入力する。

```
logProperty("name"); /* 出力結果: ['Bob', 'Smith']
logProperty("age"); /* 出力結果: 32
```

ブラケット記法については以下のオブジェクトのページでも書いた。

[オブジェクトとは](https://github.com/ren-github-account/Today-I-Learned/blob/main/JavaScript/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A8%E3%81%AF.md)

### ブラケット記法の利用場面
**オブジェクトのプロパティ名が変数で管理されている場合**にブラケット記法を使用して値にアクセスすることができる。

```
一般に、ドット記法はブラケット記法よりも簡潔で読みやすいため、より好ましいとされています。
しかし、角括弧を使用しなければならない用途もあります。 例えば、オブジェクトのプロパティ名が変数で管理されている場合、
ドット記法を使用して値にアクセスすることはできませんが、ブラケット記法を使用して値にアクセスすることは可能です。
```
引用:https://developer.mozilla.org/ja/docs/Learn/JavaScript/Objects/Basics

具体的に使い方は以下で詳しく書いた。

[ブラケット記法を使ってプロパティ名やその値を変数で管理する](#ブラケット記法を使いプロパティ名やその値を変数で管理する)

### オブジェクトの値を更新する

これまではオブジェクトから値を「取り出す」やり方だけだったが、取り出すだけではなくオブジェクトの値を「更新」することもできる。

オブジェクトの値を更新するには以下のように書く。

```
person.age = 45;

/* ブラケット記法では以下のように書く */
person["age"] = 45;
```
値が更新されているか確認するには以下のように書く。

```
person.age; /* 出力結果:45
person["age"]; /* person.ageの場合と同じ
```

### オブジェクトに新しいプロパティを追加

上記でオブジェクトの値を更新する方法を見てきたが、それだけではなくオブジェクトに「まったく新しいプロパティを追加する」こともできる。

以下のように書く。

```
person["eyes"] = "hazel";　/* personオブジェクトにeyesプロパティとその値hazelを追加。ここではブラケット記法を使用している。
　　　　　　　　　　　　　　　　hazelは黄土色っぽい色を指し、目の色を表す時に使われる。
person.farewell = function () {　/* personオブジェクトにfarewell(英語で「別れ」の意味)プロパティとその中身に関数を追加。
  console.log("Bye everybody!");
};

person.unco = "kusai";
```

呼び出す時は以下のように書く。

```
person["eyes"]; /* 出力結果:'hazel'
person.farewell(); /* 出力結果:Bye everybody! (解説:everyoneとの違いはeverybodyの方が口語的な表現)
person.unco; /* 出力結果:'kusai'
```

### 中括弧とは

本筋とは関係ないけど、MDNのJavaScript入門のページに「中括弧」という表現が出てきてわからないかったのでメモ。

中括弧とは`{}`のこと。そのほかに小括弧や大括弧もある。

表にまとめると以下になる。

||名前|
|-|-|
|`()`|小括弧。別名、丸括弧とも呼ばれる。|
|`{}`|中括弧。別名、波括弧とも呼ばれる。|
|`[]`|大括弧。別名、角括弧とも呼ばれる。|

### ブラケット記法を使ってプロパティ名やその値を変数で管理する

以下のように使う。

```
 <script>
const person = {　/* ここでpersonオブジェクトとプロパティを定義
  name:["Bob","Smith"],
  age:32
       };

const myDataName = "height";　/* この変数myDataNameがpersonオブジェクトのプロパティ名になる
const myDataValue = "1.75m";　/* この変数myDataValueがpersonオブジェクトのmyDataNameプロパティの値になる
person[myDataName] = myDataValue; /* ブラケット記法を使ってpersonオブジェクトにまったく新しいプロパティ名とその値を追加している

    </script>

```

追加されているか確認するには、以下のコードをコンソール画面に入力する。

```
person.height; /* 出力結果:'1.75m'
```

### thisとは何か

`this`は**そのコードが現在所属しているオブジェクト自体**を指している。

この`this`を使った書き方は普通に書く分にはあまりメリットは感じられないが、以下の時に役立つとのこと。
```
コンストラクターを使用して
単一のオブジェクト定義から複数のオブジェクトを作成するようになったときには不可欠なものとなります
```

**具体例**
```
const person1 = {
  name: "Chris",
  introduceSelf() {
    console.log(`Hi! I'm ${this.name}.`);　/* ここでthisはperson1オブジェクトを指している
  },
};

const person2 = {
  name: "Deepti",
  introduceSelf() {
    console.log(`Hi! I'm ${this.name}.`);　/* ここでthisはperson2オブジェクトを指している
  },
};

```

動作を確認するには以下のコードを入力。

```
person1.introduceSelf();　/* 出力結果:Hi! I'm Chris.
person1.introduceSelf(); /* 出力結果:Hi! I'm Deepti.
```

### コンストラクターの導入

これまで見てきたオブジェクトを作成するやり方は「作成したいオブジェクトの内容を一個一個書きだしていく」というやり方だった。このやり方で書かれたものをオブジェクトリテラルと呼ぶのだけど、このオブジェクトリテラルのやり方だと、一つのオブジェクトしか作らない場合なら良いけれど、複数のオブジェクトを作成しようと思ったらとても不便だ。

そこで、わざわざ一個一個入力しなくても済むように、オブジェクトのテンプレートを作成することでオブジェクトを手軽に量産できるようにしたのが **「コンストラクター」** と呼ばれるものだ。

ただ、いきなりコンストラクターのやり方を説明する前に、コンストラクターを使わずに同じことができないかをやってみる。そうすることでコンストラクターが何をやっているのかがよく理解できるし、そのありがたみもよくわかるというものだ。

**・コンストラクターを使わないver**

まず、以下のコードを書いて「作成したいオブジェクトのテンプレート」を作る。

```
function createPerson(name){ /* 引数にnameを指定
  const tanaka = {};　/* オブジェクトを作成 オブジェクト名のtanakaの部分はyamadaでもなんでも好きなやつでok
  tanaka.userName = name; /* userNameプロパティを追加
  tanaka.introduceSelf = function(){ /* introduceSelfメソッドを追加
    console.log(`Hi! I'm ${this.userName}.`);
  };
  return tanaka;　/* ここでオブジェクトの中身を返す
}
```
上記で定義した`createPerson(name)`関数は、実際に実行してみるとわかるけど、シンプルに**オブジェクトの中身を戻り値として返すだけの関数。**

そのことを確かめるには、以下のコードをコンソール画面に入力してみるとわかる。

```
createPerson(name); /* 出力結果:{userName: '', introduceSelf: ƒ}
```

このように上記の関数は`{}`で囲まれたオブジェクトの中身が表示される。

上記のコードでオブジェクト名を`tanaka`としていることから、`tanaka`はどこへいったのかと疑問に思うかもだけど、この`createPerson(name) `関数がやっていることは、出力結果を見てもわかる通り、  
単に「オブジェクトの中身」を返しているだけだ。`tanaka`の部分は`yamada`やその他の任意の文字列に変更しても同じように動作することから、そこまで気にする必要はない。

**使い方**

上記で定義した「コンストラクターを使わないver」のオブジェクトのテンプレートを実際に使ってみる。

まず、JavaScriptコードに以下を追記する。

```
const account = createPerson("Sakuma"); /* オブジェクト名をaccountとしている。
　　　　　　　　　　　　　　　　　　　　　　　createPerson(name)関数の引数に「"Sakuma"」を設定している。
　　　　　　　　　　　　　　　　　　　　　　　(この引数の部分は、文字列の場合「"Sakuma"」のようにクォーテーションで囲まないとエラーとなる。
　　　　　　　　　　　　　　　　　　　　　　　　一方で1などのような数字ならば囲まなくてもエラーは出ない)
```

あとは取り出す場合は簡単で、いつもと同じだ。以下のコードをコンソール画面に入力する。

```
account.userName; /* 出力結果:'Sakuma'
account.introduceSelf(); /* 出力結果:Hi! I'm Sakuma.
```

**・コンストラクターを使う**

上記で「コンストラクターを使わないver」を見てきた。今度はいよいよコンストラクターを使ってみようと思う。

実際にコードを書く前に、**関数をコンストラクターとして呼び出すと以下の処理が行われる**ことを頭に入れておく必要がある。

>・新しいオブジェクトを作成する
>
>・新しいオブジェクトに `this` を結び付け、コンストラクターのコードで `this` を参照することができるようにする
>
>・コンストラクターでコードを実行する
>
>・その新しいオブジェクトを返す

上記の引用にうち特に以下の2番目の部分が重要になる。

>・新しいオブジェクトに `this` を結び付け、コンストラクターのコードで `this` を参照することができるようにする

**豆知識**

英語の`constructor`には「何かを構築する人または会社」(出典:google翻訳の辞書)といった意味がある。

**使い方**

それでは実際にコンストラクターを使ってみる。

コンストラクターを使用するには、下準備として量産のもととなる関数をあらかじめ作成しておく必要があるのだけど、そのコードは**コンストラクターを使わないver**で書いた関数のコードにいくらか改変を加えて書くことができる。

比較のために「コンストラクターを使わないver」で書いた関数のコードを以下に載せる。(**変更が必要な個所はコメントで記した**)

**コンストラクターを使わないverの関数のコード (これに改変を加える)**
```
function createPerson(name){
  const tanaka = {}; /* 消去
  tanaka.userName = name; /* tanakaは「this」へ変更
  tanaka.introduceSelf = function(){　 /* ここも同じくtanakaを「this」へ変更する
    console.log(`Hi! I'm ${this.userName}.`);
  };
  return tanaka; /* 消去
}
```

上記のコードに書いたコメントの内容をもとにして、実際に書き換えた完成系が以下になる。

**コンストラクターで使う関数コードの完成系**
```
function createPerson(name){
  this.userName = name;
  this.introduceSelf = function(){
    console.log(`Hi! I'm ${this.userName}.`);
   };
 }
```

**コンストラクターを使わないverの関数のコード**から行った変更をまとめると以下になる。

||変更内容|
|-|-|
|①|オブジェクト名を定義する`const オブジェクト名 =`の行を削除。|
|②|オブジェクト名を記載していた個所をすべて`this`へと変更。|
|③|`return`の行を削除。|

実際に使用するには、まずJavaScriptのファイルに以下のコードを追記する。(コンストラクター関数の**先頭にnewを付ける点に注意**)

```
const account = new createPerson("Sakuma"); /* ここではオブジェクト名はaccountとしている。
　　　　　　　　　　　　　　　　　　　　　　　　引数の部分は「コンストラクターを使わないver」のコードと
　　　　　　　　　　　　　　　　　　　　　　　　同じだが、違う点は先頭に「new」を付けることに注意。
　　　　　　　　　　　　　　　　　　　　　　　　「new」付けないとエラーになるので注意が必要。
```

動作を確認するには以下のコードを入力する。

```
account.userName; /* 出力結果:'Sakuma'
account.introduceSelf(); /* 出力結果:Hi! I'm Sakuma.
```

最後に、先ほど引用した以下の記述の意味を確認してみる。

以下の引用は**関数をコンストラクターとして呼び出した時に行われる処理**の中の一つだ。

>・新しいオブジェクトに `this` を結び付け、コンストラクターのコードで `this` を参照することができるようにする

この引用文を、上記で書いた`const account = new createPerson("Sakuma"); `のコードに当てはめてみると、accountオブジェクトと`this`を結び付け、**コンストラクターで使う関数コードの完成系**で書いたコードで`accountオブジェクト`を参照できるようにするとなる。

### まとめ

ごちゃごちゃ書いたが、要するにコンストラクターとは **「関数を使ってオブジェクトのテンプレを作り、それを先頭に`new`を付けて呼び出す」** ってことだな。
